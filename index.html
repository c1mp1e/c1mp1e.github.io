<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>每天进步一点点</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="每天进步一点点">
<meta property="og:url" content="https://github.com/c1mp1e/c1mp1e.github.io/index.html">
<meta property="og:site_name" content="每天进步一点点">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="ccy">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/c1mp1e/c1mp1e.github.io/atom.xml" title="每天进步一点点" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/c1mp1e/c1mp1e.github.io/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/c1mp1e/c1mp1e.github.io/css/style.css">

  
    
<link rel="stylesheet" href="/c1mp1e/c1mp1e.github.io/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/c1mp1e/c1mp1e.github.io/" id="logo">每天进步一点点</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/c1mp1e/c1mp1e.github.io/">Home</a>
        
          <a class="main-nav-link" href="/c1mp1e/c1mp1e.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/c1mp1e/c1mp1e.github.io/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/c1mp1e/c1mp1e.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-leetcode31-40/leetcode做题笔记33" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/17/leetcode31-40/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B033/" class="article-date">
  <time class="dt-published" datetime="2023-07-17T14:25:54.000Z" itemprop="datePublished">2023-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/17/leetcode31-40/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B033/">leetcode做题笔记33</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<p>目录</p>
<p>思路一：循环（时间超限）</p>
<p>思路二：二分法</p>
<p>做题历程：</p>
<p>反省：</p>
<p>问题：</p>
<p>收获：</p>
<p>总结：</p>
<p>思路一：循环（时间超限）<br>虽然减小了所要循环的数的规模，但时间复杂度还是没达到要求</p>
<pre><code>    int search(int* nums, int numsSize, int target)&#123;
        if(target&gt;nums[0])
        &#123;
            int i = 1;
            while(nums[i]&lt;nums[i+1])
            &#123;
                for(;i&lt;numsSize/2;i++)
                &#123;
                    if(target==nums[i])return i;
                &#125;
                i += i/2;
            &#125;
            
            return -1;
        &#125;
        else if(target&lt;nums[0])
        &#123;
            int i = numsSize-1;
            while(nums[i]&gt;nums[i-1])
            &#123;
            for(;i&gt;numsSize/2;i--)
                &#123;
                    if(target == nums[i])return i;
                &#125;
                i -= i/2; 
            &#125;
            return -1;
        &#125;
        else return 0;
    &#125;
</code></pre>
<p>时间复杂度O(n)，空间复杂度O(1)</p>
<p>思路二：二分法<br>利用两个指针不断缩小范围，使时间复杂度达到O(logn)</p>
<pre><code>    int search(int* nums, int numsSize, int target)&#123;
        int low = 0, high = numsSize - 1;
        while(low &lt;= high)&#123;
            int mid=(high - low) / 2 + low; 
            if(nums[mid] == target)&#123; 
                return mid;
            &#125;
            if(nums[low] &lt;= nums[mid])&#123;    
                if(target &gt;= nums[low] &amp;&amp; target &lt;nums[mid])
                    high = mid - 1;
                else                                 
                    low = mid + 1;
            &#125;
            else&#123;                       
                if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[high])
                    low = mid + 1;                   
                else
                    high = mid - 1;
            &#125;
        &#125;
        return -1;
    &#125;
</code></pre>
<p>时间复杂度O(logn)，空间复杂度O(1)</p>
<p>做题历程：<br>一开始想到因为旋转了数组，可以通过判断目标数与第一个数的大小来决定是从前往后还是从后往前循环看是否相等，同时让比较的区域通过看该位置前一个与后一个比较来判断是否已到选择数的位置来决定返回-1，该方法虽然可行但是时间复杂度上还是有所欠缺，为O(n)，提交时时间超过限制，之后想到使用二分法，将数组两边用指针来不断缩小范围进行查找，将时间复杂度缩小到了O(logn)</p>
<p>反省：<br>问题：<br>时间复杂度没有降低到O(logn)</p>
<p>收获：<br>对二分法的应用更加熟练，对于是否需更改边界的条件更加明确</p>
<p>总结：<br>该题主要考察了二分法的应用，对于时间复杂度要求较高的问题，可尝试二分法来降低时间复杂度</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/17/leetcode31-40/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B033/" data-id="clk71id3v000fo4ve9mvi5dxf" data-title="leetcode做题笔记33" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode31-40/leetcode做题笔记32" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/16/leetcode31-40/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B032/" class="article-date">
  <time class="dt-published" datetime="2023-07-16T14:02:26.000Z" itemprop="datePublished">2023-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/16/leetcode31-40/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B032/">leetcode做题笔记32</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>​​<br>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。<br>目录</p>
<p>思路一：利用栈的特性解决</p>
<p>做题历程：</p>
<p>反省：</p>
<p>问题：</p>
<p>收获：</p>
<p>总结：</p>
<p>思路一：利用栈的特性解决<br>先将左括号入栈，若后面栈顶为右括号则使前一个左括号出栈，最后输出最后一个右括号和栈底左括号之间的差值</p>
<pre><code>    #define MAX(a , b) ((a) &gt; (b) ? (a) : (b))
    int longestValidParentheses(char * s)&#123;
        int len = strlen(s);
        int max = 0;
        int str[len+1];
        int top = -1;
        str[++top] = -1;
        for(int i = 0; i &lt; len; i++)
        &#123;
            if(s[i] == &#39;(&#39;)
            &#123;
                str[++top] = i;
            &#125;
            if(s[i] == &#39;)&#39;)
            &#123;
                --top;
                if(top == -1)
                &#123;
                    str[++top] = i;
                &#125;
                else
                &#123;
                    max = MAX(max , (i - str[top]));
                &#125;
            &#125;
        &#125;
        return max;
    &#125;
</code></pre>
<p>时间复杂度O(n)，空间复杂度O(n)</p>
<p>思路二：动态规划<br>做题历程：<br>因为括号的特性，使用栈会比较容易解决此类问题，使用栈的时候需要用一个指针来记录栈顶，此处使用top变量，若该位置为左括号则判断前面一位是否为右括号，为右括号则top–，最后输出最长有效括号，实际编写的过程中i的取值要考虑清楚</p>
<p>反省：<br>问题：<br>对于栈顶的判断还需考虑清楚</p>
<p>收获：<br>对括号匹配问题思路更加明确，利用栈先进后出的特性来找到匹配的括号。</p>
<p>总结：<br>括号匹配问题与栈关联紧密，熟悉栈的操作对解决括号匹配帮助很大。</p>
<p>​</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/16/leetcode31-40/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B032/" data-id="clk71id3u000do4ve4qve9lvs" data-title="leetcode做题笔记32" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode31-40/leetcode做题笔记31" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/15/leetcode31-40/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B031/" class="article-date">
  <time class="dt-published" datetime="2023-07-15T09:42:32.000Z" itemprop="datePublished">2023-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/15/leetcode31-40/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B031/">leetcode做题笔记31</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<p>目录</p>
<p>思路一：模拟题意</p>
<p>做题历程：</p>
<p>反省：</p>
<p>问题：</p>
<p>收获：</p>
<p>总结：</p>
<p>思路一：模拟题意<br>由题可想到将数组倒过来进行比较，找到较小的数，判断是否符合最大字典序，输出答案</p>
<pre><code>    void nextPermutation(int* nums, int numsSize)&#123;
        if(numsSize==1)return ;
        if(numsSize==2)&#123;
        int temp = nums[0]; 
        temp = nums[0];
        nums[0] = nums[1];
        nums[1] = temp;
        return ;
        &#125;
        int low = -1;
        for(int i = numsSize-2;i&gt;=0;i--)
        &#123;
            if(nums[i]&lt;nums[i+1])&#123;
            low = i;break;  
            &#125;
        &#125;
        if(low == -1)&#123;
            for(int i = 0;i&lt;numsSize/2;i++)
            &#123;
                int temp = nums[i];
                nums[i] = nums[numsSize-i-1];
                nums[numsSize-i-1] = temp;
            &#125;
        &#125;
        else&#123;
            for(int i = numsSize-1;i&gt;low;i--)
            &#123;
                if(nums[i]&gt;nums[low])&#123;
                    int temp = nums[low];
                    nums[low] = nums[i];
                    nums[i] = temp;
                    break;
                &#125;
            &#125;
        
        if(low!=-1)&#123;
            for(int n = low+1;n&lt;(numsSize-low-1)/2+low+1;n++)
        &#123;
            int temp = nums[n];
            nums[n] = nums[numsSize-n-1+low+1];
            nums[numsSize-n-1+low+1] = temp;
        &#125;
        &#125;
        &#125;
    
    &#125;
</code></pre>
<p>时间复杂度为O(n)，空间复杂度为O(1)</p>
<p>做题历程：<br>本题一开始想找到最大的值，通过判断最大值位置来使字典序增大，经过一段尝试后发现这种方法比较困难，因为要不断寻找末尾的最大值来进行运算，使用递归的算法可以完成，但是所需的时间，内存比较大，故放弃了这种方法，接着再审视了一遍题目，发现直接从后向前找较大的值即可，若找到则进行交换，将数组变为更大字典序的一个数组。在实际编写的过程中需注意特殊情况，即numsSize&#x3D;&#x3D;1和numsSize&#x3D;&#x3D;0的两种情况，同时要判断是否数组为最大字典序，对最大字典序的情况特殊判断。</p>
<p>反省：<br>问题：<br>对数组为最大字典序的情况考虑欠缺，一开始将整个数组直接转变顺序，后面想到要二分数组，将前面的数以中间的数为对称轴转到后面</p>
<p>收获：<br>对于字典序问题有了更深的体悟，对于交换顺序会更加严谨仔细。</p>
<p>总结：<br>该题主要考察了数组方面的知识，在数组交换顺序上需要想到以中间数为对称轴进行交换。解决方法有递归，直接交换等，此处为使时间复杂度，空间复杂度降低采用直接交换的方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/15/leetcode31-40/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B031/" data-id="clk71id3u000eo4vegazw69lz" data-title="leetcode做题笔记31" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode21-30/leetcode做题笔记30" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B030/" class="article-date">
  <time class="dt-published" datetime="2023-07-14T12:39:04.000Z" itemprop="datePublished">2023-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B030/">leetcode做题笔记30</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>​​<br>给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。</p>
<p> s 中的 串联子串 是指一个包含  words 中所有字符串以任意顺序排列连接起来的子串。</p>
<p>例如，如果 words &#x3D; [“ab”,”cd”,”ef”]， 那么 “abcdef”， “abefcd”，”cdabef”， “cdefab”，”efabcd”， 和 “efcdab” 都是串联子串。 “acdbef” 不是串联子串，因为他不是任何 words 排列的连接。<br>返回所有串联字串在 s 中的开始索引。你可以以 任意顺序 返回答案。</p>
<p>思路一：模仿题意<br>模仿题意作答，将words中的数不断转换顺序与s中字符比较，输出匹配成功的下标</p>
<p>int* findSubstring(char * s, char ** words, int wordsSize, int* returnSize){<br>    if(!wordsSize)<br>    {<br>        *returnSize &#x3D; 0;<br>        return NULL;<br>    }<br>    int len &#x3D; strlen(*words),j &#x3D; 0,x&#x3D;0,y&#x3D;0,top &#x3D; wordsSize-1;<br>    int <em>res &#x3D; (int <em>)malloc(sizeof(int));<br>    int slen &#x3D; strlen(s);<br>    int size &#x3D; wordsSize</em>len;<br>    char</em> a[wordsSize];<br>    char *check &#x3D; s;char *check2 &#x3D; s;char *b;<br>    for(int i &#x3D; 0;i&lt;wordsSize;i++)<br>    {<br>        a[i] &#x3D; words[i];<br>    }<br>    while(slen&gt;&#x3D;size)<br>    {<br>        int i &#x3D; 0,j &#x3D; 0,value;<br>        while(j&lt;wordsSize)<br>        {<br>            while(i&lt;&#x3D;top)<br>            {<br>                value &#x3D; 1;<br>                for(int k &#x3D; 0;k&lt;len;k++)<br>                {<br>                    if(check2[k]!&#x3D;a[i][k])<br>                    {<br>                        value &#x3D; 0;break;<br>                    }<br>                }<br>                if(value)<br>                {<br>                    b &#x3D; a[i];<br>                    a[i] &#x3D; a[top];<br>                    a[top] &#x3D; b;<br>                    top–;<br>                    check2+&#x3D;len;<br>                    i &#x3D; 0;<br>                    break;<br>                }<br>                else i++;</p>
<pre><code>        &#125;
        if(i&gt;0) break;
        j++;
    &#125;
    top = wordsSize-1;
    if(j==wordsSize)
    &#123;
        res = (int*)realloc(res,(x+1)*sizeof(int));
        res[x++] = y;
    &#125;
    y++;slen--;check++;check2 = check;
&#125;
*returnSize=x;
    if(!x)&#123;
        free(res);
        return NULL;
    &#125;
    else&#123;
        return res;
    &#125;
</code></pre>
<p>}</p>
<p>时间复杂度O(n^3)，空间复杂度O(n^2)</p>
<p>做题历程：<br>本题想到直接将words中字符直接排列组合后进行比较，若匹配成功则记录该下标，实际编写的过程中对于是否到达边界的判断有点无从下手，在想明白用top来记录顺序是否已经排列完全后问题迎刃而解。对于边界问题可用其他变量来表示是否越界来解决。</p>
<p>反省：<br>问题：<br>对边界问题判断有待加强，时间复杂度较高，可用哈希算法减少时间复杂度</p>
<p>收获：<br>对于字符串匹配问题更加懂得如何去解决</p>
<p>总结：<br>对于字符串匹配问题可将其放在数组中不断循环进行匹配，使用一些更快的算法有助于使运行更快。</p>
<p>​</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B030/" data-id="clk71id3s000bo4ve6sfdf7bp" data-title="leetcode做题笔记30" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode21-30/leetcode做题笔记29" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B029/" class="article-date">
  <time class="dt-published" datetime="2023-07-14T12:14:53.000Z" itemprop="datePublished">2023-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B029/">leetcode做题笔记29</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>​<br>给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。</p>
<p>整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的 商 。</p>
<p>注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−231,  231 − 1] 。本题中，如果商 严格大于 231 − 1 ，则返回 231 − 1 ；如果商 严格小于 -231 ，则返回 -231 。</p>
<p>思路一：直接将除数不断相加直到逼近被除数，即将除法转换为加法</p>
<pre><code>    int divide(int dividend, int divisor)&#123;
        int ans = 0;
        int sign = 1;
        if ((dividend ^ divisor) &lt; 0) &#123; 
            sign = -1;
        &#125;
        if (divisor == INT_MIN) &#123; 
            if (dividend == INT_MIN) &#123;
                return 1;
            &#125; else &#123;
                return 0;
            &#125;
        &#125;
        if (dividend == INT_MIN) &#123; 
            if (divisor == -1) &#123;
                return INT_MAX;
            &#125; else if (divisor == 1) &#123;
                return INT_MIN;
            &#125;
            dividend += abs(divisor); 
            ans++;
        &#125; 
        int a = abs(dividend);
        int b = abs(divisor);
        while (a &gt;= b) &#123;
            int c = 1;
            int s = b;
            while (s &lt; (a &gt;&gt; 1)) &#123; 
                s += s;
                c += c;
            &#125;
            ans += c;
            a -= s;
        &#125;
        return (sign == -1) ? -ans : ans;
    &#125;
</code></pre>
<p>​对于除数可想到变成减法，减法又可以转换为加法，所以直接将除数相加直到逼近被除数即可，实际编写代码的过程中需考虑负数的问题，此处使用sign来表示结果是否为负数，当被除数和除数一个为负数时，sign&#x3D;-1，同时需考虑边界问题，当除数和被除数大于intmax或小于intmin时要返回intmax或intmin</p>
<p>收获：对除的运算算法有了自己的理解，可以将除数转换为加减问题来进行运算</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B029/" data-id="clk71id3t000co4ve4vdk311o" data-title="leetcode做题笔记29" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode21-30/leetcode做题笔记28" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B028/" class="article-date">
  <time class="dt-published" datetime="2023-07-14T08:31:38.000Z" itemprop="datePublished">2023-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B028/">leetcode做题笔记28</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>​<br>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p>
<p>示例 1：</p>
<p>输入：haystack &#x3D; “sadbutsad”, needle &#x3D; “sad”<br>输出：0<br>解释：”sad” 在下标 0 和 6 处匹配。<br>第一个匹配项的下标是 0 ，所以返回 0 。</p>
<p>思路一：直接一个一个比对，若字符串内无法找到对于字符串则返回-1</p>
<pre><code>    int strStr(char * haystack, char * needle)&#123;
        int res =0,i=0,k,j=0;

        for(;i&lt;strlen(haystack);i++)
        &#123;
            k = i;
            if(haystack[k]==needle[0])
            &#123;
                res = k;
                for(j = 0;j&lt;strlen(needle);j++)
                &#123;
                    if(haystack[k++]!=needle[j])break;
                &#125;
                if(needle[j]==&#39;\0&#39;)break;
            &#125;
        &#125;
        if(haystack[i]!=&#39;\0&#39;)return res;
        return -1;
    &#125;
</code></pre>
<p>​时间复杂度为O(n)，空间复杂度O(1)</p>
<p>本题不难，需注意多个限制条件，若匹配完了需退出循环，且输出时看是否到了最后结束符，若未到结束符则匹配成功。实际编写的过程中，对于返回-1的位置一开始没有琢磨清楚，直接放到了不匹配的右边，后面意识到我这个匹配一开始进入循环的条件是首个字符匹配，若后面还有首个字符匹配的字符串完全匹配就会出错。</p>
<p>问题：有优化空间，可使用KMP算法进行优化，对整体问题还需理清头绪</p>
<p>收获：对于细节方面更加仔细检查，对字符串匹配问题思路更加清晰</p>
<p>思路二：KMP算法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B028/" data-id="clk71id3r000ao4ve6k1m7g0h" data-title="leetcode做题笔记28" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode21-30/leetcode做题笔记27" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B027/" class="article-date">
  <time class="dt-published" datetime="2023-07-14T03:39:45.000Z" itemprop="datePublished">2023-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B027/">leetcode做题笔记27</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>思路一：模仿题意作答</p>
<pre><code>    int removeElement(int* nums, int numsSize, int val)&#123;
        int slow = 0;

        for(int i = 0;i&lt;numsSize;i++)
        &#123;
            if(nums[i]!=val)nums[slow++]=nums[i];
        &#125;
        return slow;
    &#125;
</code></pre>
<p>时间复杂度O(n)，空间复杂度O(1)</p>
<p>直接将不等于val的所有数依次加入数组，最后返回slow即可</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B027/" data-id="clk71id3q0009o4vefm83gib7" data-title="leetcode做题笔记27" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode21-30/leetcode做题笔记26" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B026/" class="article-date">
  <time class="dt-published" datetime="2023-07-14T03:32:29.000Z" itemprop="datePublished">2023-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B026/">leetcode做题笔记26</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。</p>
<p>考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：</p>
<p>更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。<br>返回 k 。</p>
<p>思路一：双指针不断遍历删除重复值</p>
<pre><code>    int removeDuplicates(int* nums, int numsSize) &#123;
        if (numsSize == 0) &#123;
            return 0;
        &#125;
        int fast = 1, slow = 1;
        while (fast &lt; numsSize) &#123;
            if (nums[fast] != nums[fast - 1]) &#123;
                nums[slow] = nums[fast];
                ++slow;
            &#125;
            ++fast;
        &#125;
        return slow;
    &#125;
</code></pre>
<p>时间复杂度O(n)，空间复杂度O(1)</p>
<p>本题设置了两个指针，一个为快指针，一个为慢指针，若快指针遍历到相同值则不输入数组值，若不同则将不同值放入数组，最后返回慢指针的值</p>
<p>收获：对数组的处理更加娴熟。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B026/" data-id="clk71id3o0008o4vec2gra5rs" data-title="leetcode做题笔记26" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode21-30/leetcode做题笔记25" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B025/" class="article-date">
  <time class="dt-published" datetime="2023-07-14T02:48:30.000Z" itemprop="datePublished">2023-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B025/">leetcode做题笔记25</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<p>示例 1：</p>
<p>img: <a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/img_convert/bdfcd00539fd7dff76a09072273d7d74.jpeg">https://img-blog.csdnimg.cn/img_convert/bdfcd00539fd7dff76a09072273d7d74.jpeg</a></p>
<p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[2,1,4,3,5]</p>
<p>思路一：递归改变结点顺序</p>
<pre><code>    struct ListNode* reverseKGroup(struct ListNode* head, int k)&#123;
        struct ListNode *p,*q,*temp;
        if(head == NULL)return NULL;
        p = head;q = p;temp =p-&gt;next; 
        for(int i = 0;i&lt;k;i++)
        &#123;
            if(p!=NULL)
            &#123;
                p = p-&gt;next;
            &#125;else&#123;
                return head;
            &#125;
        &#125;
        p = head;
        for(int i = 1;i&lt;k;i++)
        &#123;
            if(temp)
            &#123;
                q-&gt;next = temp-&gt;next;
                temp-&gt;next = p;
                p = temp;
                temp = q-&gt;next;
            &#125;
        &#125;
        q-&gt;next = reverseKGroup(temp,k);
        return p;
    &#125;
</code></pre>
<p>时间复杂度O(n)，空间复杂度O(1)</p>
<p>与前一题类似，每k个结点反转一下顺序，直接使用递归可解答该问题，实际编写的过程中，需要判断原链表结点个数是否大于k若小于则直接返回head，当k小于结点个数时用一个中转指针将k个结点顺序转换后再使起始指针等于这个函数。</p>
<p>收获：对递归解法理解更加深入，对于k个结点反转也能做出</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B025/" data-id="clk71id3n0007o4vef2st036e" data-title="leetcode做题笔记25" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode21-30/leetcode做题笔记24" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/13/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B024/" class="article-date">
  <time class="dt-published" datetime="2023-07-13T12:28:28.000Z" itemprop="datePublished">2023-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/13/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B024/">leetcode做题笔记24</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p> </p>
<p>示例 1：</p>
<p>img: <a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/img_convert/cc4e9dd7aec216c750a324d2f1a45ce9.jpeg">https://img-blog.csdnimg.cn/img_convert/cc4e9dd7aec216c750a324d2f1a45ce9.jpeg</a></p>
<p>思路一：用两个指针不断向后遍历，遇到奇数则交换，验证得此方法可行</p>
<pre><code>    struct ListNode* swapPairs(struct ListNode* head)&#123;
    struct ListNode *p = head;
        struct ListNode *q = NULL;
        struct ListNode *res;
    if(head==NULL||head-&gt;next==NULL)&#123;
            return head;
        &#125; 
        head = head-&gt;next;
        res = head;
        for(int i = 0;head-&gt;next!=NULL;i++)
        &#123;
            if(i%2==0)&#123;
                q = head-&gt;next;
                p-&gt;next = head-&gt;next-&gt;next;
                head-&gt;next = p;
                p = q;
            &#125;
            head = head-&gt;next;
        &#125;
        if(p!=NULL)
        &#123;
            head-&gt;next = p;
            p-&gt;next = NULL;
        &#125;
        return res;
    &#125;
</code></pre>
<p> 时间复杂度为O(n)，空间复杂度为O(1)</p>
<p>此题直接模拟题意，将两个指针不断遍历原链表，遇到奇数个则交换两个指针所指的链表位置，实际编写的时候要考虑链表内数不足两个或为零的情况，最后编写出答案</p>
<p>收获：熟悉了链表交换的方法，对此类问题可采用双指针的方法</p>
<p>思路二：直接递归出答案</p>
<pre><code>    struct ListNode* swapPairs(struct ListNode* head)&#123;
    if (head == NULL || head-&gt;next == NULL) &#123;
            return head;
        &#125;
        struct ListNode* newHead = head-&gt;next;
        head-&gt;next = swapPairs(newHead-&gt;next);
        newHead-&gt;next = head;
        return newHead;
    &#125;
</code></pre>
<p> 时间复杂度为O(n)，空间复杂度为O(1)</p>
<p>第二种思路则是递归出答案，一开始使用递归时未搞清楚什么时候递归，后面直接将head-&gt;next赋值为swapPairs(newHead-&gt;next);得出答案，大大减少了代码长度。本题给的数据量不大，使用递归所耗内存较小。</p>
<p>问题：对递归的使用时机尚有欠缺</p>
<p>收获：对递归的方法掌握得更加好了，递归编写需要对问题分析到位，理解后才方便用递归</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/13/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B024/" data-id="clk71id3m0006o4vebo02d4be" data-title="leetcode做题笔记24" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/c1mp1e/c1mp1e.github.io/page/2/">2</a><a class="extend next" rel="next" href="/c1mp1e/c1mp1e.github.io/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/c1mp1e/c1mp1e.github.io/archives/2023/07/">July 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/c1mp1e/c1mp1e.github.io/2023/07/17/leetcode31-40/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B033/">leetcode做题笔记33</a>
          </li>
        
          <li>
            <a href="/c1mp1e/c1mp1e.github.io/2023/07/16/leetcode31-40/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B032/">leetcode做题笔记32</a>
          </li>
        
          <li>
            <a href="/c1mp1e/c1mp1e.github.io/2023/07/15/leetcode31-40/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B031/">leetcode做题笔记31</a>
          </li>
        
          <li>
            <a href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B030/">leetcode做题笔记30</a>
          </li>
        
          <li>
            <a href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B029/">leetcode做题笔记29</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 ccy<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/c1mp1e/c1mp1e.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/c1mp1e/c1mp1e.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/c1mp1e/c1mp1e.github.io/js/jquery-3.6.4.min.js"></script>



  
<script src="/c1mp1e/c1mp1e.github.io/fancybox/jquery.fancybox.min.js"></script>




<script src="/c1mp1e/c1mp1e.github.io/js/script.js"></script>





  </div>
</body>
</html>