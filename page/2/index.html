<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>每天进步一点点</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="每天进步一点点">
<meta property="og:url" content="https://github.com/c1mp1e/c1mp1e.github.io/page/2/index.html">
<meta property="og:site_name" content="每天进步一点点">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="ccy">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/c1mp1e/c1mp1e.github.io/atom.xml" title="每天进步一点点" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/c1mp1e/c1mp1e.github.io/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/c1mp1e/c1mp1e.github.io/css/style.css">

  
    
<link rel="stylesheet" href="/c1mp1e/c1mp1e.github.io/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/c1mp1e/c1mp1e.github.io/" id="logo">每天进步一点点</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/c1mp1e/c1mp1e.github.io/">Home</a>
        
          <a class="main-nav-link" href="/c1mp1e/c1mp1e.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/c1mp1e/c1mp1e.github.io/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/c1mp1e/c1mp1e.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-leetcode21-30/leetcode做题笔记23" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/13/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B023/" class="article-date">
  <time class="dt-published" datetime="2023-07-13T08:48:21.000Z" itemprop="datePublished">2023-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/13/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B023/">leetcode做题笔记23</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p>示例 1：</p>
<p>输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<p>思路一：</p>
<p>直接将链表里的数转换为数组里的数，用排序算法排序一遍，在用一个新链表存放返回，验证此方法可行</p>
<pre><code>    int cmp(const void*a,const void*b)
    &#123;
    return *(int*)a-*(int*)b;
    &#125;

    struct ListNode* mergeKLists(struct ListNode** lists, int listsSize)&#123;
        struct ListNode *head = NULL,*tail = NULL;
        int nums[10000] = &#123;0&#125;;
        int i = 0,j = 0,k = 0;
        for(;i&lt;listsSize;i++)
        &#123;
            while(lists[i])
            &#123;
                nums[k++] = lists[i]-&gt;val;
                lists[i] = lists[i]-&gt;next;
            &#125;
        &#125;
            qsort(nums,k,sizeof(int),cmp);
            for(i = 0;i&lt;k;i++)
            &#123;
                if(!head)
                &#123;
                    struct ListNode*p = malloc(sizeof(struct ListNode));
                    head = p;
                    tail =p;
                    p-&gt;val = nums[i];
                    p-&gt;next = NULL;
                &#125;
                else&#123;
                struct ListNode *p = malloc(sizeof(struct ListNode));
                p-&gt;val = nums[i];
                p-&gt;next = NULL;
                tail-&gt;next = p;
                tail = p;
            &#125;
            &#125;
            return head;
    &#125;
</code></pre>
<p>时间复杂度为O(N^2)，空间复杂度O(n^2)</p>
<p>本题一开始想两两合并，不断形成新链表，结果突然想到可以直接将数字都挪出来，直接排序后用链表存放返回，直接做出来了。</p>
<p>问题：时间复杂度和空间复杂度较高</p>
<p>收获：熟悉了链表的操作，遇到该类问题可考虑将链表内数放到数组里再进行比较排序，方便作答</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/13/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B023/" data-id="clk719wfg0005ocve46lzhue1" data-title="leetcode做题笔记23" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode21-30/leetcode做题笔记22" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/13/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B022/" class="article-date">
  <time class="dt-published" datetime="2023-07-13T07:53:50.000Z" itemprop="datePublished">2023-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/13/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B022/">leetcode做题笔记22</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]<br>思路一：通过判断左括号是否匹配列举所有情况返回，验证得此方法可行</p>
<pre><code>    bool isValid(char * s,int n)&#123;
        char sym[17] = &#123;0&#125;;
        int i,index = 1,time = 0,len = strlen(s);

        for(i = 0;i &lt; len;i++)&#123;
            if(s[i] == &#39;(&#39;)&#123;
                sym[index++] = s[i];
                time++;
                if(time &gt; n) return false;
                continue;
            &#125;
            if(sym[index-1] == &#39;(&#39;)&#123;    
                sym[--index] = 0;
            &#125;
            else
                return false;
        &#125;
        return true;
    &#125;
    char** set(char** s,int index,int n)&#123;
        if(index == 2*n)&#123;  
            s++; 
            for(int i = 0;i &lt; index;i++)&#123;
                s[0][i] = (s-1)[0][i];      
            &#125;
            return s;   
        &#125;
        s[0][index] = &#39;(&#39;;    
        if(isValid(s[0],n)) s = set(s,index+1,n);
        s[0][index] = &#39;)&#39;;    
        if(isValid(s[0],n)) s = set(s,index+1,n);
        s[0][index] = &#39;\0&#39;;   
        return s;
    &#125;

    char ** generateParenthesis(int n, int* returnSize)&#123;
        *returnSize = 0;

        char** ret = malloc(sizeof(char*)*(n*n*n*n+1));
        for(int i = 0;i &lt; n*n*n*n+1;i++)&#123;
            ret[i] = (char*)malloc(sizeof(char)*(2*n+1));
            memset(ret[i],0,sizeof(char)*(2*n+1));
        &#125;
        char **s = set(ret,0,n);
        *returnSize = (s - ret);  
        return ret;
    &#125;
</code></pre>
<p>时间复杂度O(n^3)，空间复杂度O(n^3)</p>
<p>本题先分析题意，列举所有情况，左括号的个数不能大于右括号，一开始想到用前左括号的个数来进行列举，左括号的个数大于右括号时创建的数组则加入右括号，这样可以模拟出全部的情况，实际编写的过程中输出一直为空，后面加上了结束符才终于正确</p>
<p>问题：对字符串数组的掌握不够深，对于结束符的编写尚有欠缺</p>
<p>收获：对括号匹配问题解决更加得心应手</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/13/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B022/" data-id="clk719wfe0003ocve099u192u" data-title="leetcode做题笔记22" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode11-20/leetcode做题笔记12" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/13/leetcode11-20/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B012/" class="article-date">
  <time class="dt-published" datetime="2023-07-13T07:48:15.107Z" itemprop="datePublished">2023-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/13/leetcode11-20/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B012/">leetcode做题笔记12</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<pre><code>字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
</code></pre>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给你一个整数，将其转为罗马数字。</p>
<p>思路一：</p>
<p>直接判断各个位数的值对应输出不同字符，验证得此方法可行</p>
<pre><code>const int values[] = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;
const char* symbols[] = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;
char * intToRoman(int num)&#123;
    char* roman = malloc(sizeof(char) * 16);
    roman[0] = &#39;\0&#39;;
    for(int i = 0 ; i &lt; 13; i++)&#123;
        while(num &gt;=values[i])&#123;
            num -= values[i];
            strcpy(roman+strlen(roman), symbols[i]);
        &#125;
        if(num == 0)
            break;
    &#125;
    return roman;
&#125;
</code></pre>
<p>时间复杂度O(1)，空间复杂度O(1)</p>
<p>本题一开始想用两个for循环嵌套，通过判断各个位数的值来进行输出，在实际编写的过程中，发现直接使用两个数组对应输出即可，可以大大减少时间复杂度，同时代码长度也有所减少，题目中给出的数的范围为1到3999，数的值不大，所以该方法比较适用于此题目。</p>
<p>收获：熟悉了构建数组，对应输出来减少时间复杂度的方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/13/leetcode11-20/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B012/" data-id="clk719wfd0002ocveeh72gq8z" data-title="leetcode做题笔记12" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode11-20/leetcode做题笔记11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/13/leetcode11-20/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B011/" class="article-date">
  <time class="dt-published" datetime="2023-07-13T07:47:28.366Z" itemprop="datePublished">2023-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/13/leetcode11-20/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B011/">leetcode做题笔记11</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>说明：你不能倾斜容器。</p>
<p>第一种思路：</p>
<p>双指针遍历数组，通过计算答案是否变大为条件，搜寻最大答案，验证得此方法</p>
<pre><code>int maxArea(int* height, int heightSize)&#123;
    int left=0,right=heightSize-1,res=0;
    while(left&lt;right)&#123;
        if(height[left]&lt;height[right])&#123;
            res = (right-left)*height[left]&gt;res?(right-left)*height[left]:res;left++;
        &#125;
        else &#123;
            res = (right-left)*height[right]&gt;res?(right-left)*height[right]:res;right--;
        &#125;
    &#125;
    return res;
&#125;
</code></pre>
<p>时间复杂度O(n)，空间复杂度O(1)</p>
<p>本题一开始想用两个for循环直接遍历找到答案，可是时间超限了 ，后面采用双指针的方法，不断判断值是否大于原答案，得到最大值。</p>
<p>问题：未考虑时间超限问题，题目给出的多个较大数的数组示例执行时时间超限</p>
<p>收获：锻炼了运用双指针的能力</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/13/leetcode11-20/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B011/" data-id="clk719wfc0001ocvedgwv5q3i" data-title="leetcode做题笔记11" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-leetcode1-10/leetcode做题笔记1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/06/leetcode1-10/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B01/" class="article-date">
  <time class="dt-published" datetime="2023-07-06T09:10:26.000Z" itemprop="datePublished">2023-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/06/leetcode1-10/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B01/">leetcode做题笔记1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>​<br>第一题 两数之和</p>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>第一种思路： </p>
<p>按照题意答题，列举每个数相加的各种情况求解，使用双for循环列举，构造数组，找到正确答案后返回答案</p>
<pre><code>        int* twoSum(int* nums, int numsSize, int target, int* returnSize) &#123;
        for (int i = 0; i &lt; numsSize; ++i) &#123;        //for循环遍历
            for (int j = i + 1; j &lt; numsSize; ++j) &#123;
                if (nums[i] + nums[j] == target) &#123;
                    int* re = malloc(sizeof(int) * 2);
                    re[0] = i, re[1] = j;
                    *returnSize = 2;
                    return re;
                &#125;
            &#125;
        &#125;
        free(re);
        *returnSize = 0;
        return NULL;
    &#125;
</code></pre>
<p>​<br>第二种思路：</p>
<p>用目标值减原数组的所有数得另一个数组，将这个数组与原数组比较，若有相同的数则输出他们的下标</p>
<pre><code>        int* twoSum(int* nums, int numsSize, int target,int *returnSize) &#123;
            int *a = malloc(sizeof(int)*2);int re[numsSize];int b[numsSize];
        for (int i = 0; i &lt; numsSize; ++i) &#123;       //将减后的数放入数组
            re[i]=target - nums[i];    
        &#125;
            for(int j = 0;j&lt;numsSize;++j)
            &#123;
                for(int k = j+1;k&lt;numsSize;++k)         //若有相同的则输出他们的下标
                &#123;
                    if(nums[j]==re[k])&#123;a[0]=j;a[1]=k;*returnSize=2; return a;&#125;
                &#125;
            
            &#125;
        *returnSize=0;
        free(a);
        return NULL;
    &#125;
</code></pre>
<p>​​<br>比较两种方法，第一种方法无需构造一个与原数组相同大小的数组，时间复杂度为O(n^2),空间复杂度为O(1),第二种方法时间复杂度为O(n^2)，空间复杂度为O(n)，相较之下，第一种方法在内存消耗上优于第二种方法。</p>
<p>第三种思路</p>
<p>因为时间复杂度过高，希望减少时间复杂度，于是利用哈希表查找插入的时间复杂度为O(1)，缩短查找的时间，先构造哈希表，利用其求解。</p>
<pre><code>    typedef struct node    //构造哈希表节点
    &#123;
        int key;
        int val;
        struct node *next;
    &#125;node,*list;

    void inithash(list hash[],int size)         //初始化哈希表
    &#123;
        for(int i = 0;i&lt;size;i++)
        &#123;
            hash[i] = (node*)malloc(sizeof(node));
            hash[i]-&gt;next = NULL;
        &#125;
    &#125;

    node *find(list hash[],int size,int key)     
    &#123;
        int pos = key &lt; 0 ? key % size + size : key % size;//判断键值是否小于零，小于零加上size
        node *p = hash[pos]-&gt;next;
        while(p&amp;&amp;p-&gt;key !=key)p = p-&gt;next;
        return p;
    &#125;

    void insert(list hash[],int size,int key,int val)
    &#123;
        int pos = key &lt; 0 ? key % size + size : key % size;
        node *n = malloc(sizeof(node));
        n-&gt;key = key;
        n-&gt;val = val;
        n-&gt;next = hash[pos]-&gt;next;
        hash[pos]-&gt;next = n;
    &#125;

        int* twoSum(int* nums, int numsSize, int target,int *returnSize) &#123;
            int size = 10000;list hash[size];int *a = malloc(sizeof(int)*2);
            inithash(hash,size);
            node *p;
            for (int i = 0; i &lt; numsSize; ++i) &#123;
            p = find(hash,size,target - nums[i]);
            if(p!=NULL)&#123;a[0]=i;a[1]=p-&gt;val;*returnSize=2; return a;&#125;
            insert(hash,size,nums[i],i);    
        &#125;
        *returnSize=0;
        free(a);
        return NULL;
    &#125;
</code></pre>
<p>​​<br>该方法时间复杂度为O(n）空间复杂度为O(n)，虽然空间复杂度逊于第一二种方法，但成功减少了时间复杂度。</p>
<p>第四种思路</p>
<p>先将原数组内数排列后可使用双指针的方法，通过判断所加值是否大于目标数使指针范围缩小，找到两个所求数输出他们的下标，验证时要考虑下标存储问题，利用数组存储下标，验证得此方法可行。</p>
<pre><code>    typedef struct data 
    &#123;
        int val;
        int index;
    &#125;data;

    int tmp(const void* a, const void* b)
    &#123;
        data* aa = (data*)a;
        data* bb = (data*)b;
        return aa-&gt;val &gt; bb-&gt;val;
    &#125;

    int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123;
        data* arr = (data*)malloc(sizeof(data) * numsSize);
        for(int i = 0; i &lt; numsSize; i++)             //存放下标
        &#123;
            arr[i].val = nums[i];
            arr[i].index = i;
        &#125;
        qsort(arr, numsSize, sizeof(data), tmp);
        int p1 = 0, p2 = numsSize - 1;
        int*ans = (int*)malloc(sizeof(int) * 2);
        while(p1 &lt; p2)        //确定数的位置
        &#123;
            if(arr[p1].val + arr[p2].val &lt; target)    
                p1++;
            else if(arr[p1].val + arr[p2].val &gt; target)
                p2--;
            else
            &#123;
                ans[0] = arr[p1].index;
                ans[1] = arr[p2].index;
                break;
            &#125;
        &#125;

        *returnSize = 2;
        return ans;

    &#125;
</code></pre>
<p>​此方法采用快速排序，时间复杂度为O(nlogn）空间复杂度为O(n)，比哈希表的方法更加容易理解。</p>
<p>总结：</p>
<p>四种方法优缺点及比较如下：</p>
<p>哈希表方法时间复杂度和空间复杂度较其他三种方法来说较优。</p>
<p>排序后用双指针的方法虽然时间复杂度略逊于哈希表的实现方法，但比哈希表的方法更加容易理解。</p>
<p>第一第二种方法，利用for循环枚举各个数相加之和与目标数是否相等，从思路来看更容易想到，且实现的过程十分简单，适用于快速解决题目。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/06/leetcode1-10/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B01/" data-id="clk719wf70000ocve2h55b8r5" data-title="leetcode做题笔记1" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/c1mp1e/c1mp1e.github.io/2023/07/01/hello-world/" class="article-date">
  <time class="dt-published" datetime="2023-07-01T13:23:30.727Z" itemprop="datePublished">2023-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/c1mp1e/c1mp1e.github.io/2023/07/01/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/c1mp1e/c1mp1e.github.io/2023/07/01/hello-world/" data-id="clk5irnnx0001cwve8opkflxa" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/c1mp1e/c1mp1e.github.io/">&laquo; Prev</a><a class="page-number" href="/c1mp1e/c1mp1e.github.io/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/c1mp1e/c1mp1e.github.io/archives/2023/07/">July 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/c1mp1e/c1mp1e.github.io/2023/07/17/leetcode31-40/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B033/">leetcode做题笔记33</a>
          </li>
        
          <li>
            <a href="/c1mp1e/c1mp1e.github.io/2023/07/16/leetcode31-40/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B032/">leetcode做题笔记32</a>
          </li>
        
          <li>
            <a href="/c1mp1e/c1mp1e.github.io/2023/07/15/leetcode31-40/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B031/">leetcode做题笔记31</a>
          </li>
        
          <li>
            <a href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B030/">leetcode做题笔记30</a>
          </li>
        
          <li>
            <a href="/c1mp1e/c1mp1e.github.io/2023/07/14/leetcode21-30/leetcode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B029/">leetcode做题笔记29</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 ccy<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/c1mp1e/c1mp1e.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/c1mp1e/c1mp1e.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/c1mp1e/c1mp1e.github.io/js/jquery-3.6.4.min.js"></script>



  
<script src="/c1mp1e/c1mp1e.github.io/fancybox/jquery.fancybox.min.js"></script>




<script src="/c1mp1e/c1mp1e.github.io/js/script.js"></script>





  </div>
</body>
</html>